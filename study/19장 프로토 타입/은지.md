# prototype

## 객체란?

상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조

- 객체의 상태 데이터 : 프로퍼티<br>
- 객체의 동작 : 메서드

자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

같은 생성자 함수로 생성된 인스턴스가 동일한 메서드를 생성할 경우 불필요하게 메모리를 사용하므로 프로토타입에 해당 메서드를 추가한다.

모든 생성자 함수로 생성하는 인스턴스는 프로토타입에서 해당 메서드를 상속받아 사용할 수 있게 된다.

<br>

## 프로토타입 객체

객체의 상위 객체의 역할을 하는 객체<br>
다른 객체에 공유 프로퍼티, 메소드를 제공<br>
프로토타입을 상속받은 자식 객체는 상위 객체의 프로퍼티를 자유롭게 사용할 수 있다.

모든 객체는 [[Prototype]]라는 내부슬롯을 가지며 이 값은 객체 생성방식에 의해 결정된다.<br>

프로토타입은 생성자 함수가 생성되는 시점에 생성된다.

### \_\_proto\_\_ 접근자

내부 슬롯에 직접 접근할수는 없지만 `__proto__` 접근자 프로퍼티로 자신의 프로토타입 내부 슬롯에 간접적으로 접근할 수 있다.
(get/set 호출)

모든 객체가 \_\_proto\_\_ 접근자를 사용할 수 있는것이 아니기 때문에 직접 사용하는것은 권장하지 않는다.

아래와 같이 `getPrototypeOf(es5)/setPrototypeOf(es6)` 를 사용하는것을 권장한다.

```javascript
const test = { x: 11 };
const obj = {
  y: 22,
  __proto__: test,
};
const change = { z: 1234 };

console.log(obj.x); // 11
console.log(Object.getPrototypeOf(obj) === test); // true

Object.setPrototypeOf(obj, change); // obj.__proto__ = change
console.log(Object.getPrototypeOf(obj)); // {z: 1234}
```

<br>

### prototype 프로퍼티

생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

함수 객체는 prototype을 소유하며 일반 객체는 소유하지 않는다.
non-constructor인 화살표 함수와 es6 메서드 축약으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않고 프로토타입도 생성하지 않는다. (17장 참조하기)

\_\_proto\_\_ 접근자 프로퍼티와 prototype 프로퍼티는 사용하는 주체가 다를뿐, 동일한 프로토타입을 가리킨다.

### constructor 프로퍼티

모든 프로토타입은 constructor 프로퍼티를 갖는다.
constructor는 자신을 참조하고있는 생성자 함수를 가리킨다.

<br>

### 프로토타입 체인

객체의 프로퍼티에 접근하려고 할 때 해당 프로퍼티가 없으면 부모의 프로토타입 프로퍼티를 순차적으로 검색한다.

자바스크립트는 프로토타입 체인을 통해 상속을 구현한다.

프로토타입 체인의 최상위 객체는 Object.prototype이다.

<br>

### 프로퍼티 섀도잉

상속관계에 의해 프로퍼티가 가려지는 현상

프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가가 된다.<br>
이때 인스턴스 메서드에 프로토타입 메서드를 오버라이딩 한 후 프로토타입의 메서드가 가려진다.

같은 이름의 프로퍼티를 삭제할 때도 마찬가지로 동작한다.

```javascript
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };

  // 생성자 함수를 반환
  return Person;
})();

const me = new Person("eunji");

// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is eunji

// 인스턴스 메서드를 삭제한다.
delete me.sayHello;
// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.
me.sayHello(); // Hi! My name is eunji
```

### 정적 프로퍼티/메서드

정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할수 있다.

```javascript
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  console.log(`Hi I'm ${this.name}`);
};

// 정적 메서드
Person.staticMethod = function () {
  console.log(`Hi this is static method`);
};

let me = new Person("eunji");

Person.prototype.sayHi(); // Hi I'm undefined
Person.staticMethod();

me.sayHi(); // Hi I'm eunji
me.staticMethod(); // Uncaught TypeError: me.staticMethod is not a function at <anonymous>:1:4
```

정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출 할 수 없다.<br>
인스턴스로 참조/호출할 수 있으려면 프로토타입 체인 상에 존재해야한다.

---

### 추가 참고하기

hasOwnProperty는 고유의 프로퍼티 키인경우에만 true를 반환한다.

for ... in 으로 객체의 프로퍼티를 열거할 수 있다.<br>
이때 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false일 경우 열거하지 않는다.<br>
for ... in은 상속받은 프로퍼티도 열거한다.

고유 프로퍼티를 열거하기위해서는 Object.keys/values/entries를 사용하는것을 권장한다.

- .keys는 프로퍼티 키를 배열로 반환
- .values는 프로퍼티 값을 배열로 반환
- .entries는 프로퍼티 키와 값의 쌍을 배열로 반환
